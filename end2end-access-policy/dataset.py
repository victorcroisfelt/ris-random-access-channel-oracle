# -*- coding: utf-8 -*-
"""2022-phd-course-deep-learning-in-5g.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kNOmP_YUbpICe9sld2sA22qWAnlDjTIX
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
from matplotlib import rc

import numpy as np

from scipy.constants import speed_of_light

# LaTeX type definitions
rc('font', **{'family': 'sans serif', 'serif': ['Computer Modern'], 'size': 12})
rc('text', usetex=True)


def channel_model(bs_gain, bs_pos,
                  ue_gain, ue_pos,
                  ris_size_el, ris_num_els_hor, ris_num_els_ver, ris_configs):
    """Get Downlink (DL) and Uplink (UL) channel gain.

    Returns
    -------
    channel_gains_dl : ndarray of shape (num_configs, num_ues)
        Downlink channel gain between the BS and each UE for each RIS configuration.

    channel_gains_ul : ndarray of shape (num_configs, num_ues)
        Uplink channel gain between the BS and each UE for each RIS configuration.

    """

    # Extract distances and angles
    bs_distance = np.linalg.norm(bs_pos)
    bs_angle = np.arctan2(bs_pos[0], bs_pos[1])

    ue_distances = np.linalg.norm(ue_pos, axis=0)
    ue_angles = np.arctan2(ue_pos[0, :], ue_pos[1, :])

    # Compute constant term
    num = bs_gain * ue_gain * (ris_size_el * ris_size_el)**2
    den = (4 * np.pi * bs_distance * ue_distances)**2

    const = num/den
    
    # Compute DL pathloss component of shape (num_ues, )
    pathloss_dl = const * np.cos(bs_angle)**2

    # Compute UL pathloss component of shape (num_ues, )
    pathloss_ul = const * np.cos(ue_angles)**2

    # Compute constant phase component of shape (num_ues, )
    distances_sum = (bs_distance + ue_distances)
    disagreement = (np.sin(bs_angle) - np.sin(ue_angles)) * ((ris_num_els_hor + 1) / 2) * ris_size_el

    phi = - wavenumber * (distances_sum - disagreement)
    
    # Compute array factor of shape (num_configs, num_ues)
    enumeration_num_els_x = np.arange(1, ris_num_els_hor + 1)
    sine_differences = (np.sin(ue_angles[np.newaxis, :, np.newaxis]) - np.sin(ris_configs[:, np.newaxis, np.newaxis]))

    argument = wavenumber * sine_differences * enumeration_num_els_x[np.newaxis, np.newaxis, :] * ris_size_el

    array_factor_dl = ris_num_els_ver * np.sum(np.exp(+1j * argument), axis=-1)
    array_factor_ul = array_factor_dl.conj()

    # Compute channel gains of shape (num_configs, num_ues)
    channel_gains_dl = np.sqrt(pathloss_dl[np.newaxis, :]) * np.exp(+1j * phi[np.newaxis, :]) * array_factor_dl
    channel_gains_ul = np.sqrt(pathloss_ul[np.newaxis, :]) * np.exp(-1j * phi[np.newaxis, :]) * array_factor_ul

    return channel_gains_dl, channel_gains_ul

########################################
# Parameters
########################################

#####
# Electromagnetic
#####

# Signal
carrier_frequency = 3e9
wavelength = speed_of_light / carrier_frequency
wavenumber = 2 * np.pi / wavelength

# SNR
noise_power_dbm = 94
transmit_power_dbm = 30

snr_dbm = 30 + 94
snr = 10**((snr_dbm - 30)/10)

#####
# RIS
#####

# Number of elements
ris_num_els_ver = ris_num_els_hor = 10  # vertical/horizontal

# Size of each element
ris_size_el = wavelength

# RIS size along one of the dimensions
ris_size = ris_num_els_ver * ris_size_el

# Minimum distant to RIS
minimum_distance = (2/wavelength) * ris_size**2

#####
# BS
#####

# BS antenna gain
bs_gain = 10**(5/10)

# Position
bs_angle = np.deg2rad([-45.0])
bs_pos = minimum_distance * np.array([np.sin(bs_angle), np.cos(bs_angle)])

#####
# UE
#####

# UE antenna gain
ue_gain = 10**(5/10)

# Maximum distance
maximum_distance = 100

########################################
# Dataset
########################################

# Number of instances
num_instances = 10000

# Number of training configurations
num_training_configs = 8

# Number of access configurations
num_access_configs = 16

# Number of symbols
num_symbols = 8

# Random generate position of the UEs
ue_angles = np.pi/2 * np.random.rand(num_instances)
ue_distances = np.sqrt(np.random.rand(num_instances) * (maximum_distance**2 - minimum_distance**2) + minimum_distance**2)

# Prepare to save UE positions
ue_pos = np.zeros((3, num_instances))

# Compute UE positions
ue_pos[0, :] = np.sin(ue_angles)
ue_pos[1, :] = np.cos(ue_angles)

# Normalize distances
ue_pos *= ue_distances

# RIS configurations
ris_angular_resolution_training = ((np.pi / 2) - 0) / num_training_configs
ris_configs_training = np.arange(ris_angular_resolution_training / 2, np.pi / 2, ris_angular_resolution_training)

ris_angular_resolution_access = ((np.pi / 2) - 0) / num_access_configs
ris_configs_access = np.arange(ris_angular_resolution_access / 2, np.pi / 2, ris_angular_resolution_access)

# Get channel gains for the UEs
channel_gains_dl_training, _ = channel_model(bs_gain, bs_pos, ue_gain, ue_pos,
                                    ris_size_el, ris_num_els_hor, ris_num_els_ver, ris_configs_training)

channel_gains_dl_training = channel_gains_dl_training.T

channel_gains_dl_access, _ = channel_model(bs_gain, bs_pos, ue_gain, ue_pos,
                                    ris_size_el, ris_num_els_hor, ris_num_els_ver, ris_configs_access)

channel_gains_dl_access = channel_gains_dl_access.T

# Generating noise
noise = np.sqrt(1/2)*(np.random.randn(num_instances, num_training_configs, num_symbols) + 1j*np.random.randn(num_instances, num_training_configs, num_symbols))

# Compute dataset
x_ = np.sqrt(snr) * channel_gains_dl_training[:, :, np.newaxis] + noise
y_ = np.abs(channel_gains_dl_access).argmax(axis=1)

####################
# Plots
####################

plt.rcParams.update({'font.size': 8})

matplotlib.rc('xtick', labelsize=6)
matplotlib.rc('ytick', labelsize=6)

matplotlib.rc('text', usetex=True)
matplotlib.rcParams['text.latex.preamble']=[r"\usepackage{amsmath}"]

# Average representative of each class
avg_representative = np.empty((num_access_configs, num_training_configs, num_symbols))

for cc in range(num_access_configs):
    avg_representative[cc]= np.mean(np.abs(x_[y_ == cc]), axis=0)

fig, axes = plt.subplots(ncols=4, nrows=4)

axes_flat = axes.flatten()

for cc in range(num_access_configs):

    im = axes_flat[cc].imshow((avg_representative[cc]))

    if cc == 0:
        axes_flat[cc].set_xlabel('cplx symbs')
        axes_flat[cc].set_ylabel('training config.')

        plt.colorbar(im)

    axes_flat[cc].set_title('access slot ' + str(cc))

    axes_flat[cc].set_xticks([1, 3, 5, 7])
    axes_flat[cc].set_yticks([1, 3, 5, 7])

plt.tight_layout()
plt.show()

# Save dataset
np.savez('dataset',
         x=x_,
         y=y_
         )