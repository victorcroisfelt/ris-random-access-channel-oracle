# -*- coding: utf-8 -*-
"""shannon-nyquist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rrWQ-d-wkfkvCnTX6grWVn6lpai5unHP
"""

import matplotlib
import matplotlib.pyplot as plt

import numpy as np

from scipy.constants import speed_of_light
import scipy.integrate as integrate

from tqdm import trange

 # LaTeX type definitions
plt.rcParams.update({
    'text.usetex': True,
    'font.family': "serif",
    'font.serif': ["Times"]
    })

#plt.rc('font', **{'family': 'serif', 'serif': ['Computer Modern'], 'size': 14})
#plt.rc('text', usetex=True)
plt.rc('text.latex', preamble=r'\usepackage{amssymb,amsmath,amsfonts,amsthm,mathtools,cuted,bbold} \usepackage[cmintegrals]{newtxmath}')

########################################
# Private functions
########################################


def integrand(x, mm, ii, fundamental_freq, comp):
    """

    :param x:
    :param mm:
    :param ii:
    :param fundamental_freq:
    :return:
    """
    result = np.exp(-1j * 2 * np.pi * fundamental_freq * (mm * np.sin(x) + ii * x))

    if comp == 'real':
        return result.real
    else:
        return result.imag


def fourier_complex_coeff(ue_angle, ris_num_els_hor, fundamental_freq, coeff_idx):
    """
    Compute the complex coefficient of the Fourier series.

    :param ue_pos:
    :param ris_size_el:
    :param ris_num_els_hor:
    :param ris_configs:
    :param fourier_terms:
    :return:
    """

    # Fundamental period
    fundamental_period = 1 / fundamental_freq

    # Enumerate elements
    enumeration_els_hor = np.arange(1, ris_num_els_hor + 1)

    # Prepare to save complex coefficient components
    components = np.zeros(ris_num_els_hor, dtype=np.complex_)

    # Go through all horizontal elements of the RIS
    for mi, mm in enumerate(enumeration_els_hor):

        # Compute constant
        cons = np.exp(1j * 2 * np.pi * fundamental_freq * mm * np.sin(ue_angle))

        # Evaluate integral
        result_real = integrate.quad(integrand, 0, np.pi/2, args=(mm, coeff_idx, fundamental_freq, 'real'), limit=500, epsabs=1e-4)
        result_imag = integrate.quad(integrand, 0, np.pi/2, args=(mm, coeff_idx, fundamental_freq, 'imag'), limit=500, epsabs=1e-4)

        # Get component
        components[mi] = 1/fundamental_period * cons * (result_real[0] + 1j * result_imag[0])

    return components.sum()


def integrand_power(x, ris_num_els_hor, ue_angles, fundamental_freq):
    """

    :param x:
    :param ris_num_els_hor:
    :param ue_angle:
    :param fundamental_freq:
    :return:
    """

    # Enumerate elements
    enumeration_els_hor = np.arange(1, ris_num_els_hor + 1)

    # Compute result
    result = np.abs((np.exp(1j * 2 * np.pi * fundamental_freq * enumeration_els_hor * (np.sin(ue_angles) - np.sin(x)))).sum())**2

    return result


def average_power(ue_angles, ris_num_els_hor, fundamental_freq):
    """

    :param ue_pos:
    :param ris_num_els_hor:
    :param fundamental_freq:
    :return:
    """

    # Fundamental period
    fundamental_period = 1 / fundamental_freq

    # Prepare to save average power
    avg_power = np.zeros_like(ue_angles)

    # Go through all angles
    for ue, angle in enumerate(ue_angles):

        # Solve integral
        result = integrate.quad(integrand_power, 0, np.pi/2, args=(ris_num_els_hor, angle, fundamental_freq), epsabs=1e-4)

        # Compute average power
        avg_power[ue] = 1/fundamental_period * result[0]

    return avg_power


########################################
# Parameters
########################################

# Electromagnetics
carrier_frequency = 3e9
wavelength = speed_of_light / carrier_frequency
wavenumber = 2 * np.pi / wavelength

# Number of horizontal elements
ris_num_els_hor = 10

# Size of each element
ris_size_el = wavelength/2

########################################
# Evaluating maximum frequency
########################################

# Define fundamental frequency
fundamental_freq = 0.5

# Define range of UE's angle
ue_angles = np.linspace(0, np.pi/2)

# Compute average power
avg_power = average_power(ue_angles, ris_num_els_hor, fundamental_freq)

# Define range of epsilon
epsilon_range = 10**(-np.array([1, 2, 3], dtype=float))

# Prepare to save smallest symmetric interval
interval = np.zeros((epsilon_range.size, ue_angles.size))

# Go through all UE's angles
for ue in trange(ue_angles.size, desc='Simulating', unit='positions'):

    # Extract current angle
    angle = ue_angles[ue]

    # Store complex coefficients
    complex_coeffs = {}

    # Compute basic complex coefficient
    complex_coeffs[0] = fourier_complex_coeff(angle, ris_num_els_hor, fundamental_freq, 0)
    complex_coeffs[-1] = fourier_complex_coeff(angle, ris_num_els_hor, fundamental_freq, -1)
    complex_coeffs[+1] = fourier_complex_coeff(angle, ris_num_els_hor, fundamental_freq, +1)

    # Compute temp index
    coeff_idx = 2

    while True:

        # Evaluate coservation efficiency
        true_ratio = (np.abs(list(complex_coeffs.values())) ** 2).sum() / avg_power[ue]

        if true_ratio < 1 - epsilon_range[-1]:

            # Compute complex coefficients
            complex_coeffs[+coeff_idx] = fourier_complex_coeff(angle, ris_num_els_hor, fundamental_freq, +coeff_idx)
            complex_coeffs[-coeff_idx] = fourier_complex_coeff(angle, ris_num_els_hor, fundamental_freq, -coeff_idx)

            # Update temp index
            coeff_idx += 1

        else:
            break

    # Create a copy
    epsilon_list = list(epsilon_range)

    # Create temp variable
    coeff_idx = 1

    # Store temporally the results
    temp = []

    while True:

        # Indexes
        rang = np.arange(-coeff_idx, coeff_idx+1)

        # Get values
        values = [complex_coeffs[ii] for ii in rang]

        # Evaluate sum
        approx_avg_power = (np.abs(values)**2).sum()

        # Ratio
        ratio = approx_avg_power/avg_power[ue]

        if len(epsilon_list) == 1:

            # Store coeff_idx
            temp.append(-list(complex_coeffs.keys())[-1])

            # Update list
            del epsilon_list[0]

        else:

            if ratio > (1 - epsilon_list[0]):

                # Store coeff_idx
                temp.append(coeff_idx)

                # Update list
                del epsilon_list[0]

        if len(epsilon_list) == 0:
            break

        # Update temp var
        coeff_idx += 1

    # Store simulation result
    interval[:, ue] = temp

# Compute approximated maximum frequency according to Method 1
appr_max_freq_1 = fundamental_freq * ris_num_els_hor

# Compute approximated maximum frequency according to Method 2
appr_max_freq_2 = fundamental_freq * interval

#np.savez('max_freq', result=result)

########################################
# Plot
########################################
fig, ax = plt.subplots(figsize=(6.5, 3))

styles = ['--', '-.', ':']
labels = [r'$\tilde{F}^{10^{-1}}_{\max}$ in (23)', r'$\tilde{F}^{10^{-2}}_{\max}$ in (23)', r'$\tilde{F}^{10^{-3}}_{\max}$ in (23)']

ax.plot(np.rad2deg(ue_angles), appr_max_freq_1 * np.ones_like(ue_angles), linestyle='-', color='black', linewidth=1.5, label=r'$\tilde{F}_{\max}$ in (16)')

# Go through all epsilons
for ii, epsilon in enumerate(epsilon_range):
    ax.plot(np.rad2deg(ue_angles), appr_max_freq_2[ii, :], linestyle=styles[ii], color='black', linewidth=1.5, label=labels[ii])

ax.set_ylabel('Approx. maximum \n frequency, ' + r'$\tilde{F}_{\max,k}$')
ax.set_xlabel(r"UE's angle, $\theta_k$ in degrees")

ax.set_xticks(np.arange(0, 100, 10))

plt.xticks(fontsize=12)
plt.yticks(fontsize=12)

ax.set_yscale('log')

ax.legend(fontsize='small', framealpha=0.5)

ax.grid(color='#E9E9E9', linestyle=':', linewidth=1.0, alpha=0.5)

#plt.tight_layout()

plt.subplots_adjust(
    left = 0.125,
    right = 0.99,
    bottom = 0.175,
    top = 0.95,
    wspace = 0.5,
    hspace = 0.05
    )

plt.savefig('max_freq.pdf', dpi='figure', format='pdf', transparent='True')

plt.show()
