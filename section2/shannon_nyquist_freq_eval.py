# -*- coding: utf-8 -*-
"""shannon-nyquist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rrWQ-d-wkfkvCnTX6grWVn6lpai5unHP
"""

import matplotlib
import matplotlib.pyplot as plt
from matplotlib import rc

import numpy as np

from scipy.constants import speed_of_light
from scipy.fft import fft, fftfreq, fftshift
from scipy import interpolate

plt.rc('text', usetex=True)
plt.rc('text.latex', preamble=r'\usepackage{amsmath} \usepackage{amsmath} \usepackage{amssymb}')

# matplotlib.rc('font', **{'family': 'sans serif', 'serif': ['Computer Modern'], 'size': 12})
#
# matplotlib.rc('xtick', labelsize=8)
# matplotlib.rc('ytick', labelsize=8)
#
# matplotlib.rc('text', usetex=True)
#
# matplotlib.rcParams['text.latex.preamble'] = [
#     r'\usepackage{amsfonts}',
#     r'',
#     r''
# ]


def channel_model(bs_gain, bs_pos,
                  ue_gain, ue_pos,
                  ris_size_el, ris_num_els_hor, ris_num_els_ver, ris_configs
                  ):
    """Get downlink channel gains.

    Returns
    -------
    channel_gains_dl : ndarray of shape (num_configs, num_ues)

    """

    # Extract distances and angles
    bs_distance = np.linalg.norm(bs_pos)
    bs_angle = np.arctan2(bs_pos[0], bs_pos[1])

    ue_distances = np.linalg.norm(ue_pos, axis=0)
    ue_angles = np.arctan2(ue_pos[0, :], ue_pos[1, :])

    # Compute DL pahloss of shape (num_ues, )
    num = bs_gain * ue_gain * (ris_size_el * ris_size_el)**2
    den = (4 * np.pi * bs_distance * ue_distances)**2

    const = num/den
    
    pathloss_dl = const * np.cos(bs_angle)**2

    # Compute fundamental frequency 
    fundamental_freq = ris_size_el / wavelength

    # Compute term 1
    term1 = np.sqrt(pathloss_dl) * ris_num_els_ver

    # Compute term 2
    term2 = np.exp(1j * 2 * np.pi * fundamental_freq * ((bs_distance + ue_distances) / ris_size_el))

    # Compute term 3
    term3 = np.exp(-1j  * 2 * np.pi * fundamental_freq * (ris_num_els_hor + 1) / 2 * (np.sin(bs_angle) - np.sin(ue_angles)))

    # Compute term 4
    enumeration_num_els_x = np.arange(1, ris_num_els_hor + 1)

    term4 = np.exp(1j * 2 * np.pi * fundamental_freq * enumeration_num_els_x[:, None, None] * (np.sin(ue_angles)[:, None] - np.sin(ris_configs)[None, :]))
    term4 = term4.transpose(1, 0, 2)

    return term1, term2, term3, term4


def fourier_complex_coeff(ue_pos, ris_size_el, ris_num_els_hor, ris_configs, fourier_terms):

    # Get UE angles
    ue_angles = np.arctan2(ue_pos[0, :], ue_pos[1, :])

    # Compute fundamental frequency
    fundamental_freq = ris_size_el / wavelength

    # Enumerate elements
    enumeration_num_els_x = np.arange(1, ris_num_els_hor + 1)

    # Prepare to save Fourier complex coefficients
    complex_coeffs = np.zeros((ue_pos.shape[1], fourier_terms.size), dtype=np.complex_)

    for idx, ii in enumerate(fourier_terms):

        # Compute fourier c coefficients
        complex_coeffs_part1 = np.exp(1j * 2 * np.pi * fundamental_freq * enumeration_num_els_x[None, :] * np.sin(ue_angles[:, None])).sum(axis=-1)
        complex_coeffs_part2 = ((ii + enumeration_num_els_x) * np.exp(1j * 2 * np.pi * fundamental_freq * enumeration_num_els_x[None, :] * np.sin(ue_angles[:, None]))).sum(axis=-1)
        complex_coeffs_part3 = ((ii + enumeration_num_els_x)**2 * np.exp(1j * 2 * np.pi * fundamental_freq * enumeration_num_els_x[None, :] * np.sin(ue_angles[:, None]))).sum(axis=-1)

        complex_coeffs[:, idx] = complex_coeffs_part1 - 1j * np.pi * complex_coeffs_part2 / fundamental_freq - 2/3 * np.pi**2 * complex_coeffs_part3 / fundamental_freq

    return complex_coeffs


########################################
# Parameters
########################################

# Electromagnetics
carrier_frequency = 3e9
wavelength = speed_of_light / carrier_frequency
wavenumber = 2 * np.pi / wavelength

# RIS

# Number of elements
ris_num_els_ver = ris_num_els_hor = 10  # vertical/horizontal

# Size of each element
ris_size_el = wavelength/2

# RIS size along one of the dimensions
ris_size = ris_num_els_ver * ris_size_el

# Minimum distance to the RIS
minimum_distance = (2 / wavelength) * ris_size**2

# BS

# BS antenna gain
bs_gain = 10**(5/10)

# BS position
bs_angle = np.deg2rad([-45.0])
bs_pos = minimum_distance * np.array([np.sin(bs_angle), np.cos(bs_angle)])

# UE

# UE antenna gain
ue_gain = 10**(5/10)

# Define specific positions for the UEs
#ue_angles_deg = np.array([30.0, 45.0, 60.0])
ue_angles_deg = np.array([45.0])
ue_angles = np.deg2rad(ue_angles_deg)

# Prepare to save UE positions
ue_pos = np.zeros((3, ue_angles_deg.size))

# Compute UE positions
ue_pos[0, :] = np.sin(ue_angles)
ue_pos[1, :] = np.cos(ue_angles)

ue_pos *= minimum_distance

########################################
# Generating signal
########################################

# Compute fundamental frequency
fundamental_frequency = ris_size_el / wavelength

# Number of configurations or samples
ris_num_configs = 1001

# Spatial duration of the signal
spatial_duration = (np.pi/2 - 0)

# Sampling period and frequency
sampling_period = spatial_duration/ris_num_configs
sampling_frequency = 1/sampling_period

# Spatial step
spatial_step = np.linspace(0, spatial_duration, ris_num_configs)

# Generate signal
term1, term2, term3, term4 = channel_model(
    bs_gain, bs_pos,
    ue_gain, ue_pos,
    ris_size_el, ris_num_els_hor, ris_num_els_ver, spatial_step)

signal = term4[0, :, :].sum(axis=0)

########################################
# Sampling signal
########################################

# Number of configurations or samples
num_samples = 21

# Spatial duration of the signal
spatial_duration = (np.pi/2 - 0)

# Sampling period and frequency
sampling_period = spatial_duration/num_samples
sampling_frequency = 1/sampling_period

# Spatial step
spatial_step_sampled = np.linspace(0, spatial_duration, num_samples)

# Generate signal
term1, term2, term3, term4 = channel_model(
    bs_gain, bs_pos,
    ue_gain, ue_pos,
    ris_size_el, ris_num_els_hor, ris_num_els_ver, spatial_step_sampled)

signal_sampled = term4[0, :, :].sum(axis=0)

########################################
# PLot signal
########################################
fig, axes = plt.subplots(2, 1)

axes[0].plot(np.rad2deg(spatial_step), signal.real, color='black')
axes[1].plot(np.rad2deg(spatial_step), signal.imag, color='black')

axes[0].stem(np.rad2deg(spatial_step_sampled), signal_sampled.real)
axes[1].stem(np.rad2deg(spatial_step_sampled), signal_sampled.imag)

axes[0].set_xlabel(r'config. angle $\theta_s$ in degrees')
axes[1].set_xlabel(r'config. angle $\theta_s$ in degrees')

axes[0].set_ylabel(r'$\mathfrak{Re}(a_k(\theta_s))$')
axes[1].set_ylabel(r'$\mathfrak{Im}(a_k(\theta_s))$')

axes[0].set_xticks(np.arange(0, 90, 10))
axes[1].set_xticks(np.arange(0, 90, 10))

# axes[0].legend(fontsize='x-small', framealpha=0.5)

axes[0].grid(color='gray', linestyle=':', linewidth=0.5, alpha=0.5)
axes[1].grid(color='gray', linestyle=':', linewidth=0.5, alpha=0.5)

plt.tight_layout()

########################################
# Frequency analysis
########################################

# Compute FFT
signal_freq = fft(signal_sampled)

# Compute frequency x-axis
freq = fftfreq(num_samples, d=sampling_period)

# Prepare for plot
freq_plot = fftshift(freq)
signal_freq_plot = fftshift(signal_freq)

# Plot FFT
fig, ax = plt.subplots()

ax.plot(freq_plot, (1 / num_samples) * np.abs(signal_freq_plot))

########################################
# Signal reconstruction
########################################

# Apply zero-order reconstruction
zero_order_f_real = interpolate.interp1d(spatial_step_sampled, signal_sampled.real)
zero_order_f_imag = interpolate.interp1d(spatial_step_sampled, signal_sampled.imag)

fig, axes = plt.subplots(2, 1)

axes[0].plot(np.rad2deg(spatial_step), signal.real, color='black')
axes[1].plot(np.rad2deg(spatial_step), signal.imag, color='black')

axes[0].plot(np.rad2deg(spatial_step_sampled), zero_order_f_real(spatial_step_sampled), linestyle=':')
axes[1].plot(np.rad2deg(spatial_step_sampled), zero_order_f_imag(spatial_step_sampled), linestyle=':')

axes[0].set_xlabel(r'config. angle $\theta_s$ in degrees')
axes[1].set_xlabel(r'config. angle $\theta_s$ in degrees')

axes[0].set_ylabel(r'$\mathfrak{Re}(a_k(\theta_s))$')
axes[1].set_ylabel(r'$\mathfrak{Im}(a_k(\theta_s))$')

axes[0].set_xticks(np.arange(0, 90, 10))
axes[1].set_xticks(np.arange(0, 90, 10))

# axes[0].legend(fontsize='x-small', framealpha=0.5)

axes[0].grid(color='gray', linestyle=':', linewidth=0.5, alpha=0.5)
axes[1].grid(color='gray', linestyle=':', linewidth=0.5, alpha=0.5)

plt.show()
#
#
# #-----
# # BS
# #-----
#
#
#
# #-----
# # UE
# #-----
#
#
#
#
#
# # Get constant term
# constant = term1 * term2 * term3
#
#
#
#
# # Define Fourier terms
# fourier_terms = np.array([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5])
#
# complex_coeffs = fourier_complex_coeff(ue_pos, ris_size_el, ris_num_els_hor, ris_configs, fourier_terms)
#
# fig, ax = plt.subplots()
#
# ax.stem(fourier_terms, np.abs(np.squeeze(complex_coeffs))**2)
#
# plt.show()

