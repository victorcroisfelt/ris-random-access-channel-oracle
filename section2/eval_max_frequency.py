# -*- coding: utf-8 -*-
"""shannon-nyquist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rrWQ-d-wkfkvCnTX6grWVn6lpai5unHP
"""

import matplotlib
import matplotlib.pyplot as plt

import numpy as np

from scipy.constants import speed_of_light
import scipy.integrate as integrate

from tqdm import trange

plt.rc('text', usetex=True)
plt.rc('text.latex', preamble=r'\usepackage{amsmath} \usepackage{amsmath} \usepackage{amssymb}')
matplotlib.rc('font', **{'family': 'sans serif', 'serif': ['Computer Modern'], 'size': 8})

########################################
# Private functions
########################################


def integrand(x, mm, ii, fundamental_freq, comp):
    """

    :param x:
    :param mm:
    :param ii:
    :param fundamental_freq:
    :return:
    """
    result = np.exp(-1j * 2 * np.pi * fundamental_freq * (mm * np.sin(x) + ii * x))

    if comp == 'real':
        return result.real
    else:
        return result.imag


def fourier_complex_coeff(ue_angle, ris_num_els_hor, fundamental_freq, coeff_idx):
    """
    Compute the complex coefficient of the Fourier series.

    :param ue_pos:
    :param ris_size_el:
    :param ris_num_els_hor:
    :param ris_configs:
    :param fourier_terms:
    :return:
    """

    # Fundamental period
    fundamental_period = 1 / fundamental_freq

    # Enumerate elements
    enumeration_els_hor = np.arange(1, ris_num_els_hor + 1)

    # Prepare to save complex coefficient components
    components = np.zeros(ris_num_els_hor, dtype=np.complex_)

    # Go through all horizontal elements of the RIS
    for mi, mm in enumerate(enumeration_els_hor):

        # Compute constant
        cons = np.exp(1j * 2 * np.pi * fundamental_freq * mm * np.sin(ue_angle))

        # Evaluate integral
        result_real = integrate.quad(integrand, 0, np.pi/2, args=(mm, coeff_idx, fundamental_freq, 'real'), limit=500, epsabs=1e-4)
        result_imag = integrate.quad(integrand, 0, np.pi/2, args=(mm, coeff_idx, fundamental_freq, 'imag'), limit=500, epsabs=1e-4)

        # Get component
        components[mi] = 1/fundamental_period * cons * (result_real[0] + 1j * result_imag[0])

    return components.sum()


def integrand_power(x, ris_num_els_hor, ue_angles, fundamental_freq):
    """

    :param x:
    :param ris_num_els_hor:
    :param ue_angle:
    :param fundamental_freq:
    :return:
    """

    # Enumerate elements
    enumeration_els_hor = np.arange(1, ris_num_els_hor + 1)

    # Compute result
    result = np.abs((np.exp(1j * 2 * np.pi * fundamental_freq * enumeration_els_hor * (np.sin(ue_angles) - np.sin(x)))).sum())**2

    return result


def average_power(ue_angles, ris_num_els_hor, fundamental_freq):
    """

    :param ue_pos:
    :param ris_num_els_hor:
    :param fundamental_freq:
    :return:
    """

    # Fundamental period
    fundamental_period = 1 / fundamental_freq

    # Prepare to save average power
    avg_power = np.zeros_like(ue_angles)

    # Go through all angles
    for ue, angle in enumerate(ue_angles):

        # Solve integral
        result = integrate.quad(integrand_power, 0, np.pi/2, args=(ris_num_els_hor, angle, fundamental_freq), epsabs=1e-4)

        # Compute average power
        avg_power[ue] = 1/fundamental_period * result[0]

    return avg_power


########################################
# Parameters
########################################

# Electromagnetics
carrier_frequency = 3e9
wavelength = speed_of_light / carrier_frequency
wavenumber = 2 * np.pi / wavelength

# Number of horizontal elements
ris_num_els_hor = 10

# Size of each element
ris_size_el = wavelength/2

# Define specific positions for the UEs
ue_angles = np.linspace(0, np.pi/2)

########################################
# Evaluating maximum frequency
########################################

# Compute fundamental frequency
fundamental_freq = 0.5

# Compute average power
avg_power = average_power(ue_angles, ris_num_els_hor, fundamental_freq)

# Define range of epsilon
epsilon_range = 10**(-np.array([1, 2, 3], dtype=float))

# Prepare to save results
result = np.zeros((epsilon_range.size, ue_angles.size))

# Go through all UE's angles
for ue in trange(ue_angles.size, desc='Simulating', unit='positions'):

    # Extract current angle
    angle = ue_angles[ue]

    # Define complex coefficient indexes
    complex_coeff_idxs = np.arange(-400, 400)

    # Store complex coefficients
    complex_coeffs = {}

    # Go through all indexes
    for ii in complex_coeff_idxs:

        # Compute complex coefficient
        complex_coeffs[ii] = fourier_complex_coeff(angle, ris_num_els_hor, fundamental_freq, ii)

    # Evaluate
    true_ratio = (np.abs(list(complex_coeffs.values())) ** 2).sum() / avg_power[ue]

    if true_ratio < 1 - 10**(-3):
        print('error')
        break

    # Create a copy
    epsilon_list = list(epsilon_range)

    # Create range bounds
    bound = 1

    # Store temporally the results
    temp = []

    while True:

        # Indexes
        rang = np.arange(-bound, bound+1)

        # Get values
        values = [complex_coeffs[ii] for ii in rang]

        # Evaluate sum
        approx_avg_power = (np.abs(values)**2).sum()

        # Ratio
        ratio = approx_avg_power/avg_power[ue]

        if len(epsilon_list) > 0:

            if ratio > (1 - epsilon_list[0]):

                # Store bound
                temp.append(bound)

                # Update list
                del epsilon_list[0]

        else:
            break

        # Update bound
        bound += 1

    # Store simtion results
    result[:, ue] = temp

np.savez('result',
         result=result)

########################################
# Plot
########################################
fig, ax = plt.subplots(figsize=(3.15, 3/2))

styles = ['--', '-.', ':']
labels = ['10^{-1}', '10^{-2}', '10^{-3}']

ax.plot(np.rad2deg(ue_angles), ris_num_els_hor * np.ones_like(ue_angles), linestyle='-', color='black', linewidth=1.5, label=r'$\tilde{I}=M_x=10$')

# Go through all epsilons
for ii, epsilon in enumerate(epsilon_range):
    ax.plot(np.rad2deg(ue_angles), result[ii, :], linestyle=styles[ii], color='black', linewidth=1.5, label=r'$\epsilon=' + str(labels[ii]) + '$')

#ax.set_yscale('log')

ax.set_ylabel(r'interval, $I^{\epsilon}_k$')
ax.set_xlabel(r"UE's angle, $\theta_k$ in degress")

ax.set_xticks(np.arange(0, 100, 10))

ax.set_yscale('log')

ax.legend(fontsize='x-small', framealpha=0.5)

ax.grid(color='gray', linestyle=':', linewidth=0.5, alpha=0.5)

plt.tight_layout()

plt.show()
