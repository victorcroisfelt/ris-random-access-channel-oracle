# -*- coding: utf-8 -*-
"""shannon-nyquist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rrWQ-d-wkfkvCnTX6grWVn6lpai5unHP
"""

import matplotlib
import matplotlib.pyplot as plt

import math
import numpy as np

from scipy.constants import speed_of_light
from scipy import interpolate

from tqdm import trange
from commonfunc import dl_channel_gains

plt.rc('text', usetex=True)
plt.rc('text.latex', preamble=r'\usepackage{amsmath} \usepackage{amsmath} \usepackage{amssymb}')
matplotlib.rc('font', **{'family': 'sans serif', 'serif': ['Computer Modern'], 'size': 8})

########################################
# System Parameters
########################################

# Electromagnetic
carrier_frequency = 3e9
wavelength = speed_of_light / carrier_frequency
wavenumber = 2 * np.pi / wavelength

# Define maximum distance
maximum_distance = 100

# RIS

# Number of elements
ris_num_els_ver = ris_num_els_hor = 10  # vertical/horizontal

# Size of each element
ris_size_el = wavelength/2

# RIS size along one of the dimensions
ris_size = ris_num_els_ver * ris_size_el

# Minimum distance to the RIS (far-field)
minimum_distance = (2 / wavelength) * ris_size**2

# BS

# BS antenna gain
bs_gain = 10**(5/10)

# BS position
bs_angle = np.deg2rad([-45.0])
bs_pos = minimum_distance * np.array([math.sin(bs_angle), math.cos(bs_angle), 0])

########################################
# Generating UEs
########################################

# Define number of UEs
num_ues = 1000

# UE antenna gain
ue_gain = 10**(5/10)

# Generate distances
ue_distances = np.sqrt(np.random.rand(num_ues) * (maximum_distance ** 2 - minimum_distance ** 2) + minimum_distance ** 2)

# Generate angles
ue_angles = (np.pi / 2) * np.random.rand(num_ues)

# Get UE positions
ue_pos = np.zeros((3, num_ues))

# Compute UE positions
ue_pos[0, :] = np.sin(ue_angles)
ue_pos[1, :] = np.cos(ue_angles)

ue_pos *= ue_distances

########################################
# Generating true channel gains
########################################

# Number of configurations or samples
ris_num_configs_true = 1001

# Signal range
signal_range = (np.pi/2 - 0)

# Sampling period and frequency
sampling_period = signal_range/ris_num_configs_true
sampling_frequency = 1/sampling_period

# Spatial step
ris_configs_true = np.linspace(0, signal_range, ris_num_configs_true)

# Generate signal
channel_gains_true = dl_channel_gains(
    wavelength,
    bs_gain, bs_pos,
    ue_gain, ue_pos,
    ris_size_el, ris_num_els_hor, ris_num_els_ver, ris_configs_true)

########################################
# Simulation parameters
########################################

# Define MVU error tolerance
tolerance = 0.01

# Define SNR range
snr_db_range = np.linspace(-10, 10, 101)

# Transform SNR linear
snr_range = 10**(snr_db_range/10)

# Number of noise realizations
num_noise_realizations = 100

# Compute fundamental frequency
fundamental_frequency = ris_size_el / wavelength

# Range of the number of configurations or samples
ris_num_configs_range = np.array([26, 142, 16])

# Signal range
signal_range = (np.pi/2 - 0)

# Range number of configurations range
num_range = ris_num_configs_range.size

# Prepare to save reconstruction MSEs
mse_recon_true = np.zeros((num_range, snr_range.size, num_ues))
mse_recon = np.zeros((num_range, snr_range.size, num_ues))

# Go through all number of configurations
for cc in trange(num_range, desc='outer loop', unit="configs"):

    # Get the current number of configurations
    ris_num_configs = ris_num_configs_range[cc]

    # Sampling period and frequency
    sampling_period = signal_range/ris_num_configs
    sampling_frequency = 1/sampling_period

    # Spatial step
    ris_configs = np.linspace(0, signal_range, ris_num_configs)

    # Generate signal
    channel_gains = dl_channel_gains(
        wavelength,
        bs_gain, bs_pos,
        ue_gain, ue_pos,
        ris_size_el, ris_num_els_hor, ris_num_els_ver, ris_configs)

    # Go through each UE
    for ue in range(num_ues):

        ####################
        # True reconstruction
        ####################

        # Apply zero-order reconstruction
        zero_order_f_real = interpolate.interp1d(ris_configs, channel_gains[ue, :].real)
        zero_order_f_imag = interpolate.interp1d(ris_configs, channel_gains[ue, :].imag)

        # Get values
        zero_order_real = zero_order_f_real(ris_configs_true)
        zero_order_imag = zero_order_f_imag(ris_configs_true)

        # Reconstructed signal
        channel_gains_recon_true = zero_order_real + 1j * zero_order_imag

        # Evaluate true reconstruction MSE
        mse_recon_true[cc, :, ue] = (np.abs(channel_gains_true[ue, :] - channel_gains_recon_true)**2).mean()

        # Generate equivalent noise
        noise = (np.random.randn(ris_num_configs) + 1j * np.random.randn(ris_num_configs))

        # Go through all SNR values
        for ss in range(snr_range.size):

            # Extract current SNR
            snr = snr_range[ss]

            ####################
            # Estimated reconstruction
            ####################

            # Compute the number of channel uses
            num_channel_uses_ce = int(np.ceil(1 / (snr * tolerance)))

            # Normalize noise
            noise *= np.sqrt(1 / (2 * num_channel_uses_ce * snr))

            # Get estimated channel gains
            estimated_channel_gains = channel_gains[ue, :, None] + noise

            # Apply zero-order reconstruction
            zero_order_f_real = interpolate.interp1d(ris_configs, estimated_channel_gains.real)
            zero_order_f_imag = interpolate.interp1d(ris_configs, estimated_channel_gains.imag)

            # Get values
            zero_order_real = zero_order_f_real(ris_configs_true)
            zero_order_imag = zero_order_f_imag(ris_configs_true)

            # Reconstructed signal
            channel_gains_recon = zero_order_real + 1j * zero_order_imag

            # Evaluate MSE
            mse_recon[cc, ss, ue] = (np.abs(channel_gains_true[ue, :] - channel_gains_recon)**2).mean()

# Take the average in terms of noise realizations
avg_mse_recon = mse_recon#.mean(axis=-1)

########################################
# Plot reconstruction MSE
########################################

styles = ['-', '--', '-.', ':']
colors = ['#ffe74c', '#ff5964', '#38618c']
labels = [r'$\bar{N}^{10^{-2}}_{\mathrm{ce}}=26$', r'$\check{N}^{10^{-2}}_{\mathrm{ce}}=142$', r'$\tilde{N}^{10^{-2}}_{\mathrm{ce}}=16$']

fig, ax = plt.subplots(figsize=(3.15, 3))

# Go through all number of configurations
for cc in range(num_range):

    ax.plot(snr_db_range, np.mean(avg_mse_recon[cc, :], axis=-1), linewidth=1.5, linestyle=styles[cc], color=colors[cc], label=labels[cc])
    ax.fill_between(snr_db_range, np.percentile(avg_mse_recon[cc, :], 25, axis=-1), np.percentile(avg_mse_recon[cc, :], 75, axis=-1), alpha=0.5, color=colors[cc])

ax.set_xlabel(r'$\mathrm{SNR}^{\rm DL}$ [dB]')
ax.set_ylabel(r'reconstruction MSE')

ax.set_yscale('log')

ax.legend(fontsize='x-small', loc='best')
ax.grid(color='gray', linestyle=':', linewidth=0.5, alpha=0.5)

plt.tight_layout()

plt.show()

