# -*- coding: utf-8 -*-
"""shannon-nyquist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rrWQ-d-wkfkvCnTX6grWVn6lpai5unHP
"""

import matplotlib
import matplotlib.pyplot as plt

import math
import numpy as np

from scipy.constants import speed_of_light
from scipy import interpolate

from tqdm import trange
from commonfunc import dl_channel_gains

plt.rc('text', usetex=True)
plt.rc('text.latex', preamble=r'\usepackage{amsmath} \usepackage{amsmath} \usepackage{amssymb}')
matplotlib.rc('font', **{'family': 'sans serif', 'serif': ['Computer Modern'], 'size': 8})

########################################
# System Parameters
########################################

# Electromagnetic
carrier_frequency = 3e9
wavelength = speed_of_light / carrier_frequency
wavenumber = 2 * np.pi / wavelength

# Define maximum distance
maximum_distance = 100

# RIS

# Number of elements
ris_num_els_ver = ris_num_els_hor = 10  # vertical/horizontal

# Size of each element
ris_size_el = wavelength/2

# RIS size along one of the dimensions
ris_size = ris_num_els_ver * ris_size_el

# Minimum distance to the RIS (far-field)
minimum_distance = (2 / wavelength) * ris_size**2

# BS

# BS antenna gain
bs_gain = 10**(5/10)

# BS position
bs_angle = np.deg2rad([-45.0])
bs_pos = minimum_distance * np.array([math.sin(bs_angle), math.cos(bs_angle), 0])

########################################
# Generating UEs
########################################

# Define number of UEs
num_ues = 1000

# UE antenna gain
ue_gain = 10**(5/10)

# Generate distances
ue_distances = np.sqrt(np.random.rand(num_ues) * (maximum_distance ** 2 - minimum_distance ** 2) + minimum_distance ** 2)

# Generate angles
ue_angles = (np.pi / 2) * np.random.rand(num_ues)

# Get UE positions
ue_pos = np.zeros((3, num_ues))

# Compute UE positions
ue_pos[0, :] = np.sin(ue_angles)
ue_pos[1, :] = np.cos(ue_angles)

ue_pos *= ue_distances

########################################
# Generating true channel gains
########################################

# Number of configurations or samples
ris_num_configs_true = 1001

# Signal range
signal_range = (np.pi/2 - 0)

# Sampling period and frequency
sampling_period = signal_range/ris_num_configs_true
sampling_frequency = 1/sampling_period

# Spatial step
ris_configs_true = np.linspace(0, signal_range, ris_num_configs_true)

# Generate signal
channel_gains_true = dl_channel_gains(
    wavelength,
    bs_gain, bs_pos,
    ue_gain, ue_pos,
    ris_size_el, ris_num_els_hor, ris_num_els_ver, ris_configs_true)

########################################
# Simulation parameters
########################################

# Define MVU error tolerance
tolerance = 10e-3

# Define SNR
snr_db = 0

# Transform SNR linear
snr = 10**(snr_db/10)

# Compute fundamental frequency
fundamental_frequency = ris_size_el / wavelength

# Signal range
signal_range = (np.pi/2 - 0)

# Number of noise realizations
num_noise_realizations = 100

# Range of the number of configurations or samples
ris_num_configs_range = np.arange(10, 150, 10)

# Range number of configurations range
num_range = ris_num_configs_range.size

# Prepare to save reconstruction MSEs
mse_recon_true = np.zeros((num_range, num_ues))
#mse_recon = np.zeros((num_range, num_ues, num_noise_realizations))
mse_recon = np.zeros((num_range, num_ues))

# Go through all number of configurations
for cc in trange(num_range, desc='simulating', unit="configs"):

    # Get the current number of configurations
    ris_num_configs = ris_num_configs_range[cc]

    # Sampling period and frequency
    sampling_period = signal_range/ris_num_configs
    sampling_frequency = 1/sampling_period

    # Spatial step
    ris_configs = np.linspace(0, signal_range, ris_num_configs)

    # Generate signal
    channel_gains = dl_channel_gains(
        wavelength,
        bs_gain, bs_pos,
        ue_gain, ue_pos,
        ris_size_el, ris_num_els_hor, ris_num_els_ver, ris_configs)

    # Go through each UE
    for ue in range(num_ues):

        ####################
        # True reconstruction
        ####################

        # Apply zero-order reconstruction
        zero_order_f_real = interpolate.interp1d(ris_configs, channel_gains[ue, :].real)
        zero_order_f_imag = interpolate.interp1d(ris_configs, channel_gains[ue, :].imag)

        # Get values
        zero_order_real = zero_order_f_real(ris_configs_true)
        zero_order_imag = zero_order_f_imag(ris_configs_true)

        # Reconstructed signal
        channel_gains_recon_true = zero_order_real + 1j * zero_order_imag

        # Evaluate true reconstruction MSE
        mse_recon_true[cc, ue] = (np.abs(channel_gains_true[ue, :] - channel_gains_recon_true)**2).mean()

        ####################
        # Estimated reconstruction
        ####################

        # Compute the number of channel uses
        num_channel_uses_ce = int(np.ceil(1 / (snr * tolerance)))

        # Generate equivalent noise
        noise = (np.random.randn(ris_num_configs) + 1j * np.random.randn(ris_num_configs))
        noise *= np.sqrt(1 / (2 * num_channel_uses_ce * snr))

        # Get estimated channel gains
        estimated_channel_gains = channel_gains[ue, :] + noise

        # # Go through each noise realization
        # for rr in range(num_noise_realizations):

        # Apply zero-order reconstruction
        zero_order_f_real = interpolate.interp1d(ris_configs, estimated_channel_gains.real)
        zero_order_f_imag = interpolate.interp1d(ris_configs, estimated_channel_gains.imag)

        # Get values
        zero_order_real = zero_order_f_real(ris_configs_true)
        zero_order_imag = zero_order_f_imag(ris_configs_true)

        # Reconstructed signal
        channel_gains_recon = zero_order_real + 1j * zero_order_imag

        # Evaluate MSE
        mse_recon[cc, ue] = (np.abs(channel_gains_true[ue, :] - channel_gains_recon)**2).mean()

# Take the average in terms of noise realizations
avg_mse_recon = mse_recon#.mean(axis=-1)

########################################
# Plot reconstruction MSE
########################################
fig, ax = plt.subplots(figsize=(3.15, 3))

ax.plot(ris_num_configs_range, np.mean(mse_recon_true, axis=-1), color='black', linewidth=1.5, linestyle='-')
#ax.fill_between(ris_num_configs_range, np.percentile(mse_recon_true, 25, axis=-1), np.percentile(mse_recon_true, 75, axis=-1), color='black', alpha=0.5)
ax.fill_between(ris_num_configs_range, np.min(mse_recon_true, axis=-1), np.max(mse_recon_true, axis=-1), color='black', alpha=0.5)

ax.plot(ris_num_configs_range, np.mean(avg_mse_recon, axis=-1), linewidth=1.5, linestyle='--')
#ax.fill_between(ris_num_configs_range, np.percentile(avg_mse_recon, 25, axis=-1), np.percentile(avg_mse_recon, 75, axis=-1), alpha=0.5)
ax.fill_between(ris_num_configs_range, np.min(avg_mse_recon, axis=-1), np.max(avg_mse_recon, axis=-1), alpha=0.5)

ax.set_xlabel(r'number of configurations, $N_{\mathrm{ce}}$')
ax.set_ylabel(r'reconstruction MSE')

ax.set_yscale('log')

ax.grid(color='gray', linestyle=':', linewidth=0.5, alpha=0.5)

#ax.legend(fontsize='x-small', loc='best')

plt.tight_layout()

plt.show()
